import{_ as a,c as o,o as d,ag as i}from"./chunks/framework.u6_mHqbc.js";const k=JSON.parse('{"title":"背景","description":"","frontmatter":{},"headers":[],"relativePath":"zh/documentation/theming/background.md","filePath":"zh/documentation/theming/background.md"}'),c={name:"zh/documentation/theming/background.md"};function r(t,e,l,n,s,h){return d(),o("div",null,e[0]||(e[0]=[i(`<h1 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h1><p>SukiUI 的背景渲染器可利用 GPU 加速和着色器来绘制复杂的运行时背景效果，且这些效果会随着主题变化。</p><p>本页提到的所有属性都可以通过 <code>SukiWindow</code> 中的 <code>Background{Property}</code> 属性访问。如果你希望在其他上下文中托管一个 <code>SukiBackground</code> 控件，那么这些属性应该采用类似的命名方式，但不需要 <code>Background</code> 前缀。</p><h2 id="样式" tabindex="-1">样式 <a class="header-anchor" href="#样式" aria-label="Permalink to &quot;样式&quot;">​</a></h2><p>通过 <code>BackgroundStyle</code> 可以更改默认的样式，包括 <code>Gradient</code>（渐变）、<code>Flat</code>（纯色）和 <code>Bubble</code>（气泡）。你也可以通过用 SKSL 编写的自定义着色器来创建自己的背景。</p><p>这里提供两种编写自定义着色器的方法：</p><h4 id="backgroundshaderfile" tabindex="-1">BackgroundShaderFile <a class="header-anchor" href="#backgroundshaderfile" aria-label="Permalink to &quot;BackgroundShaderFile&quot;">​</a></h4><p>通过将嵌入的资源文件包含在你的应用中，并使用正确的文件扩展名（例如 <code>MyShader.sksl</code>），只需将 <code>BackgroundShaderFile</code> 属性设置为文件名（不带扩展名）。SukiUI 会自动在你的嵌入资源中搜索该文件并加载着色器。</p><p>SukiUI 也有一些着色器可以通过这种方式访问，如 <code>Cells</code> 和 <code>Waves</code>。</p><h4 id="backgroundshadercode" tabindex="-1">BackgroundShaderCode <a class="header-anchor" href="#backgroundshadercode" aria-label="Permalink to &quot;BackgroundShaderCode&quot;">​</a></h4><p>可以不嵌入文件，直接将表示着色器的 SKSL 字符串赋值给此属性，就可以创建运行时效果并渲染。你也可以与该属性建立绑定以在运行时动态更改着色器代码，任何更改都会立即更新渲染结果。</p><h4 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h4><p>当选择要渲染的背景样式时，如果同时有多个属性被设置，SukiUI 将按照以下顺序处理：<code>BackgroundShaderFile</code> -&gt; <code>BackgroundShaderCode</code> -&gt; <code>BackgroundStyle</code></p><h2 id="自定义样式" tabindex="-1">自定义样式 <a class="header-anchor" href="#自定义样式" aria-label="Permalink to &quot;自定义样式&quot;">​</a></h2><p>在 SukiUI，必须编写 <a href="https://github.com/google/skia/blob/main/src/sksl/README.md" target="_blank" rel="noreferrer">SKSL</a> 以渲染自定义背景。</p><p>这可能在一开始显得有些复杂，但语言本身很简单，你需要编写一个入口函数，该函数返回一个 <code>vec4</code>，表示每个像素的颜色。借助 GPU 的并行计算，可以非常快速地执行大量相对复杂的数学运算。</p><p>在编译着色器之前，SukiUI 会在这些效果中提供一组可用的变量（uniforms），供你在着色器中使用：</p><ul><li><code>float iTime</code> - 背景开始渲染以来的时间刻度，仅在启用动画时变化。</li><li><code>float iDark</code> - 应用是处于<code>light</code>主题还是<code>dark</code>主题，0 表示<code>light</code>，1 表示<code>dark</code>。</li><li><code>float iAlpha</code> - 背景的透明度，主要由背景控件的透明度控制。</li><li><code>vec3 iResolution</code> - 背景的分辨率，以像素为单位，且只有<code>x</code> 和 <code>y</code>是有效的，<code>z</code> 始终为 0。</li><li><code>vec3 iPrimary</code> - 当前主题色的（不完全）表示。</li><li><code>vec3 iAccent</code> - 当前强调主题色的（不完全）表示。</li><li><code>vec3 iBase</code> - 预先计算的主题背景色，如果应用在<code>light</code>主题下则偏白色。</li></ul><p>这些变量会自动包含在你提供的任何着色器文件或代码中，可以像使用全局变量一样使用它们。它们会随着每一帧更新，并且应用程序状态的任何更改都会反映在这些变量中。</p><p>最简单的着色器示例是我们的 <code>Flat</code> 样式，它只返回每个像素的基础背景颜色：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vec4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vec2 </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fragCoord</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iBase, iAlpha);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="过渡效果" tabindex="-1">过渡效果 <a class="header-anchor" href="#过渡效果" aria-label="Permalink to &quot;过渡效果&quot;">​</a></h2><p>启用 <code>BackgroundTransitionsEnabled</code> 后，任何背景样式的更改都可以通过简单的透明度切换来实现“淡入淡出”，这也是 <code>iAlpha</code> 属性的主要用途。</p><p>可以设置 <code>BackgroundTransitionTime</code> 来定义过渡时间，单位为秒（默认为 1 秒）。</p><h2 id="动画" tabindex="-1">动画 <a class="header-anchor" href="#动画" aria-label="Permalink to &quot;动画&quot;">​</a></h2><p>SukiUI 的背景渲染器支持动画（以原生帧率运行），且通过 <code>BackgroundAnimationEnabled</code> 启用。除 <code>Flat</code> 以外，所有默认的 SukiUI 背景都支持动画。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>由于需要重绘整个<a href="https://docs.avaloniaui.net/zh-Hans/docs/concepts/control-trees#%E5%8F%AF%E8%A7%86%E6%A0%91" target="_blank" rel="noreferrer">可视树</a>，启用动画会对性能产生显著影响，因此建议仅在必要时使用。在一些测试中，我们发现启用动画时 CPU 使用率大约增加 5%，而 GPU 使用率增加约 20%。</p></div><h2 id="考虑软件渲染" tabindex="-1">考虑软件渲染？ <a class="header-anchor" href="#考虑软件渲染" aria-label="Permalink to &quot;考虑软件渲染？&quot;">​</a></h2><p>如果 <a href="https://github.com/mono/SkiaSharp" target="_blank" rel="noreferrer">SkiaSharp</a>（Avalonia 的渲染引擎）没有发现任何可用的硬件加速，SukiUI 将回到软件渲染的解决方案，即在 CPU 上渲染 <code>Flat</code> 背景样式。</p>`,29)]))}const u=a(c,[["render",r]]);export{k as __pageData,u as default};
